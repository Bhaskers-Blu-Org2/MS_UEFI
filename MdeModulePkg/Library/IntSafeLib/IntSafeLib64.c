/**

Copyright (c) 2017, Microsoft Corporation

All rights reserved.
Redistribution and use in source and binary forms, with or without 
modification, are permitted provided that the following conditions are met:
1. Redistributions of source code must retain the above copyright notice,
this list of conditions and the following disclaimer.
2. Redistributions in binary form must reproduce the above copyright notice,
this list of conditions and the following disclaimer in the documentation
 and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, 
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF 
ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

This library provides helper functions to prevent integer overflow during
type conversion, addition, subtraction, and multiplication.

NOTE: DO NOT EDIT THIS FILE, IT IS AUTO-GENERATED!

**/

#include <Base.h>
#include <Library/IntSafeLib.h>

//
// SafeUInt32x32To64 macro
//
#define SafeUInt32x32To64(a, b) (((UINT64)(a)) * ((UINT64)(b)))

//
// Min type values
//
#define MIN_INT8        (-127i8 - 1)
#define MIN_INT16       (-32768)
#define MIN_INT32         (-2147483647 - 1)
#define MIN_INT64    (-9223372036854775807i64 - 1)
#define MIN_INTN    (-9223372036854775807i64 - 1)

//
// It is common for -1 to be used as an error value
//
#define INT8_ERROR      (-1i8)
#define UINT8_ERROR     0xffui8
#define INT16_ERROR     (-1)
#define UINT16_ERROR    0xffff
#define CHAR16_ERROR    0xffffui16
#define INT32_ERROR       (-1)
#define UINT32_ERROR      0xffffffff
#define INT64_ERROR  (-1i64)
#define UINT64_ERROR 0xffffffffffffffffui64
#define INTN_ERROR  (-1i64)
#define UINTN_ERROR 0xffffffffffffffffui64

//=============================================================================
// Conversion functions
//
// There are three reasons for having conversion functions:
//
// 1. We are converting from a signed type to an unsigned type of the same
//    size, or vice-versa.
//
// 2. We are converting to a smaller type, and we could therefore possibly
//    overflow.
//
// 3. We are converting to a bigger type, and we are signed and the type we are
//    converting to is unsigned.
//
//=============================================================================


//
// INT8 -> UINT8 conversion
//
RETURN_STATUS
EFIAPI
SafeInt8ToUInt8(
    IN INT8 Operand,
    OUT UINT8* Result
    )
{
    RETURN_STATUS Status;
    
    if (Operand >= 0)
    {
        *Result = (UINT8)Operand;
        Status = RETURN_SUCCESS;
    }
    else
    {
        *Result = UINT8_ERROR;
        Status = RETURN_BUFFER_TOO_SMALL;
    }
    
    return Status;
}

//
// INT8 -> UINT16 conversion
//
RETURN_STATUS
EFIAPI
SafeInt8ToUInt16(
    IN INT8 Operand,
    OUT UINT16* Result
    )
{
    RETURN_STATUS Status;
    
    if (Operand >= 0)
    {
        *Result = (UINT16)Operand;
        Status = RETURN_SUCCESS;
    }
    else
    {
        *Result = UINT16_ERROR;
        Status = RETURN_BUFFER_TOO_SMALL;
    }
    
    return Status;
}


//
// INT8 -> UINT32 conversion
//
RETURN_STATUS
EFIAPI
SafeInt8ToUInt32(
    IN INT8 Operand,
    OUT UINT32* Result
    )
{
    RETURN_STATUS Status;
    
    if (Operand >= 0)
    {
        *Result = (UINT32)Operand;
        Status = RETURN_SUCCESS;
    }
    else
    {
        *Result = UINT32_ERROR;
        Status = RETURN_BUFFER_TOO_SMALL;
    }
    
    return Status;
}

//
// INT8 -> UINTN conversion
//
RETURN_STATUS
EFIAPI
SafeInt8ToUIntN(
    IN INT8 Operand,
    OUT UINTN* Result
    )
{
    RETURN_STATUS Status;
    
    if (Operand >= 0)
    {
        *Result = (UINTN)Operand;
        Status = RETURN_SUCCESS;
    }
    else
    {
        *Result = UINTN_ERROR;
        Status = RETURN_BUFFER_TOO_SMALL;
    }
    
    return Status;
}

//
// INT8 -> UINT64 conversion
//
RETURN_STATUS
EFIAPI
SafeInt8ToUInt64(
    IN INT8 Operand,
    OUT UINT64* Result
    )
{
    RETURN_STATUS Status;
    
    if (Operand >= 0)
    {
        *Result = (UINT64)Operand;
        Status = RETURN_SUCCESS;
    }
    else
    {
        *Result = UINT64_ERROR;
        Status = RETURN_BUFFER_TOO_SMALL;
    }
    
    return Status;
}

//
// UINT8 -> INT8 conversion
//
RETURN_STATUS
EFIAPI
SafeUInt8ToInt8(
    IN UINT8 Operand,
    OUT INT8* Result
    )
{
    RETURN_STATUS Status;
    
    if (Operand <= MAX_INT8)
    {
        *Result = (INT8)Operand;
        Status = RETURN_SUCCESS;
    }
    else
    {
        *Result = INT8_ERROR;
        Status = RETURN_BUFFER_TOO_SMALL;
    }
    
    return Status;
}

//
// UINT8 -> CHAR8 conversion
//
RETURN_STATUS
EFIAPI
SafeUInt8ToChar8(
    IN UINT8 Operand,
    OUT CHAR8* Result
    )
{
    return SafeUInt8ToInt8(Operand, (INT8*)Result);
}

//
// INT16 -> INT8 conversion
//
RETURN_STATUS
EFIAPI
SafeInt16ToInt8(
    IN INT16 Operand,
    OUT INT8* Result
    )
{
    RETURN_STATUS Status;

    if ((Operand >= MIN_INT8) && (Operand <= MAX_INT8))
    {
        *Result = (INT8)Operand;
        Status = RETURN_SUCCESS;
    }
    else
    {
        *Result = INT8_ERROR;
        Status = RETURN_BUFFER_TOO_SMALL;
    }

    return Status;
}

//
// INT16 -> CHAR8 conversion
//
RETURN_STATUS
EFIAPI
SafeInt16ToChar8(
    IN INT16 Operand,
    OUT CHAR8* Result
    )
{
    return SafeInt16ToInt8(Operand, (INT8*)Result);
}

//
// INT16 -> UINT8 conversion
//
RETURN_STATUS
EFIAPI
SafeInt16ToUInt8(
    IN INT16 Operand,
    OUT UINT8* pui8Result
    )
{
    RETURN_STATUS Status;

    if ((Operand >= 0) && (Operand <= MAX_UINT8))
    {
        *pui8Result = (UINT8)Operand;
        Status = RETURN_SUCCESS;
    }
    else
    {
        *pui8Result = UINT8_ERROR;
        Status = RETURN_BUFFER_TOO_SMALL;
    }

    return Status;
}

//
// INT16 -> UINT16 conversion
//
RETURN_STATUS
EFIAPI
SafeInt16ToUInt16(
    IN INT16 Operand,
    OUT UINT16* Result
    )
{
    RETURN_STATUS Status;

    if (Operand >= 0)
    {
        *Result = (UINT16)Operand;
        Status = RETURN_SUCCESS;
    }
    else
    {
        *Result = UINT16_ERROR;
        Status = RETURN_BUFFER_TOO_SMALL;
    }

    return Status;
}

//
// INT16 -> UINT32 conversion
//
RETURN_STATUS
EFIAPI
SafeInt16ToUInt32(
    IN INT16 Operand,
    OUT UINT32* Result
    )
{
    RETURN_STATUS Status;

    if (Operand >= 0)
    {
        *Result = (UINT32)Operand;
        Status = RETURN_SUCCESS;
    }
    else
    {
        *Result = UINT32_ERROR;
        Status = RETURN_BUFFER_TOO_SMALL;
    }

    return Status;
}

//
// INT16 -> UINTN conversion
//
RETURN_STATUS
EFIAPI
SafeInt16ToUIntN(
    IN INT16 Operand,
    OUT UINTN* Result
    )
{
    RETURN_STATUS Status;
    
    if (Operand >= 0)
    {
        *Result = (UINTN)Operand;
        Status = RETURN_SUCCESS;
    }
    else
    {
        *Result = UINTN_ERROR;
        Status = RETURN_BUFFER_TOO_SMALL;
    }
    
    return Status;
}

//
// INT16 -> UINT64 conversion
//
RETURN_STATUS
EFIAPI
SafeInt16ToUInt64(
    IN INT16 Operand,
    OUT UINT64* Result
    )
{
    RETURN_STATUS Status;

    if (Operand >= 0)
    {
        *Result = (UINT64)Operand;
        Status = RETURN_SUCCESS;
    }
    else
    {
        *Result = UINT64_ERROR;
        Status = RETURN_BUFFER_TOO_SMALL;
    }
    
    return Status;
}

//
// UINT16 -> INT8 conversion
//
RETURN_STATUS
EFIAPI
SafeUInt16ToInt8(
    IN UINT16 Operand,
    OUT INT8* Result
    )
{
    RETURN_STATUS Status;
    
    if (Operand <= MAX_INT8)
    {
        *Result = (INT8)Operand;
        Status = RETURN_SUCCESS;
    }
    else
    {
        *Result = INT8_ERROR;
        Status = RETURN_BUFFER_TOO_SMALL;
    }

    return Status;
}

//
// UINT16 -> CHAR8 conversion
//
RETURN_STATUS
EFIAPI
SafeUInt16ToChar8(
    IN UINT16 Operand,
    OUT CHAR8* Result
    )
{
    return SafeUInt16ToInt8(Operand, (INT8*)Result);
}

//
// UINT16 -> UINT8 conversion
//
RETURN_STATUS
EFIAPI
SafeUInt16ToUInt8(
    IN UINT16 Operand,
    OUT UINT8* pui8Result
    )
{
    RETURN_STATUS Status;
    
    if (Operand <= MAX_UINT8)
    {
        *pui8Result = (UINT8)Operand;
        Status = RETURN_SUCCESS;
    }
    else
    {
        *pui8Result = UINT8_ERROR;
        Status = RETURN_BUFFER_TOO_SMALL;
    }
    
    return Status;
}

//
// UINT16 -> INT16 conversion
//
RETURN_STATUS
EFIAPI
SafeUInt16ToInt16(
    IN UINT16 Operand,
    OUT INT16* Result
    )
{
    RETURN_STATUS Status;

    if (Operand <= MAX_INT16)
    {
        *Result = (INT16)Operand;
        Status = RETURN_SUCCESS;
    }
    else
    {
        *Result = INT16_ERROR;
        Status = RETURN_BUFFER_TOO_SMALL;
    }

    return Status;
}

//
// INT32 -> INT8 conversion
//
RETURN_STATUS
EFIAPI
SafeInt32ToInt8(
    IN INT32 Operand,
    OUT INT8* Result
    )
{
    RETURN_STATUS Status;
    
    if ((Operand >= MIN_INT8) && (Operand <= MAX_INT8))
    {
        *Result = (INT8)Operand;
        Status = RETURN_SUCCESS;
    }
    else
    {
        *Result = INT8_ERROR;
        Status = RETURN_BUFFER_TOO_SMALL;
    }
    
    return Status;
}

//
// INT32 -> CHAR8 conversion
//
RETURN_STATUS
EFIAPI
SafeInt32ToChar8(
    IN INT32 Operand,
    OUT CHAR8* Result
    )
{
    return SafeInt32ToInt8(Operand, (INT8*)Result);
}

//
// INT32 -> UINT8 conversion
//
RETURN_STATUS
EFIAPI
SafeInt32ToUInt8(
    IN INT32 Operand,
    OUT UINT8* pui8Result
    )
{
    RETURN_STATUS Status;
    
    if ((Operand >= 0) && (Operand <= MAX_UINT8))
    {
        *pui8Result = (UINT8)Operand;
        Status = RETURN_SUCCESS;
    }
    else
    {
        *pui8Result = UINT8_ERROR;
        Status = RETURN_BUFFER_TOO_SMALL;
    }
    
    return Status;
}

//
// INT32 -> INT16 conversion
//
RETURN_STATUS
EFIAPI
SafeInt32ToInt16(
    IN INT32 Operand,
    OUT INT16* Result
    )
{
    RETURN_STATUS Status;

    if ((Operand >= MIN_INT16) && (Operand <= MAX_INT16))
    {
        *Result = (INT16)Operand;
        Status = RETURN_SUCCESS;
    }
    else
    {
        *Result = INT16_ERROR;
        Status = RETURN_BUFFER_TOO_SMALL;
    }

    return Status;
}

//
// INT32 -> UINT16 conversion
//
RETURN_STATUS
EFIAPI
SafeInt32ToUInt16(
    IN INT32 Operand,
    OUT UINT16* Result
    )
{
    RETURN_STATUS Status;

    if ((Operand >= 0) && (Operand <= MAX_UINT16))
    {
        *Result = (UINT16)Operand;
        Status = RETURN_SUCCESS;
    }
    else
    {
        *Result = UINT16_ERROR;
        Status = RETURN_BUFFER_TOO_SMALL;
    }

    return Status;
}

//
// INT32 -> UINT32 conversion
//
RETURN_STATUS
EFIAPI
SafeInt32ToUInt32(
    IN INT32 Operand,
    OUT UINT32* Result
    )
{
    RETURN_STATUS Status;

    if (Operand >= 0)
    {
        *Result = (UINT32)Operand;
        Status = RETURN_SUCCESS;
    }
    else
    {
        *Result = UINT32_ERROR;
        Status = RETURN_BUFFER_TOO_SMALL;
    }

    return Status;
}

//
// INT32 -> UINTN conversion
//
RETURN_STATUS
EFIAPI
SafeInt32ToUIntN(
    IN INT32 Operand,
    OUT UINTN* Result
    )
{
    return SafeInt32ToUInt64(Operand, (UINT64*) Result);
}

//
// INT32 -> UINT64 conversion
//
RETURN_STATUS
EFIAPI
SafeInt32ToUInt64(
    IN INT32 Operand,
    OUT UINT64* Result
    )
{
    RETURN_STATUS Status;

    if (Operand >= 0)
    {
        *Result = (UINT64)Operand;
        Status = RETURN_SUCCESS;
    }
    else
    {
        *Result = UINT64_ERROR;
        Status = RETURN_BUFFER_TOO_SMALL;
    }

    return Status;
}

//
// UINT32 -> INT8 conversion
//
RETURN_STATUS
EFIAPI
SafeUInt32ToInt8(
    IN UINT32 Operand,
    OUT INT8* Result
    )
{
    RETURN_STATUS Status;
    
    if (Operand <= MAX_INT8)
    {
        *Result = (INT8)Operand;
        Status = RETURN_SUCCESS;
    }
    else
    {
        *Result = INT8_ERROR;
        Status = RETURN_BUFFER_TOO_SMALL;
    }
    
    return Status;
}    

//
// UINT32 -> CHAR8 conversion
//
RETURN_STATUS
EFIAPI
SafeUInt32ToChar8(
    IN UINT32 Operand,
    OUT CHAR8* Result
    )
{
    return SafeUInt32ToInt8(Operand, (INT8*)Result);
}

//
// UINT32 -> UINT8 conversion
//
RETURN_STATUS
EFIAPI
SafeUInt32ToUInt8(
    IN UINT32 Operand,
    OUT UINT8* pui8Result
    )
{
    RETURN_STATUS Status;
    
    if (Operand <= MAX_UINT8)
    {
        *pui8Result = (UINT8)Operand;
        Status = RETURN_SUCCESS;
    }
    else
    {
        *pui8Result = UINT8_ERROR;
        Status = RETURN_BUFFER_TOO_SMALL;
    }
    
    return Status;
}    

//
// UINT32 -> INT16 conversion
//
RETURN_STATUS
EFIAPI
SafeUInt32ToInt16(
    IN UINT32 Operand,
    OUT INT16* Result
    )
{
    RETURN_STATUS Status;

    if (Operand <= MAX_INT16)
    {
        *Result = (INT16)Operand;
        Status = RETURN_SUCCESS;
    }
    else
    {
        *Result = INT16_ERROR;
        Status = RETURN_BUFFER_TOO_SMALL;
    }

    return Status;
}

//
// UINT32 -> UINT16 conversion
//
RETURN_STATUS
EFIAPI
SafeUInt32ToUInt16(
    IN UINT32 Operand,
    OUT UINT16* Result
    )
{
    RETURN_STATUS Status;

    if (Operand <= MAX_UINT16)
    {
        *Result = (UINT16)Operand;
        Status = RETURN_SUCCESS;
    }
    else
    {
        *Result = UINT16_ERROR;
        Status = RETURN_BUFFER_TOO_SMALL;
    }

    return Status;
}

//
// UINT32 -> INT32 conversion
//
RETURN_STATUS
EFIAPI
SafeUInt32ToInt32(
    IN UINT32 Operand,
    OUT INT32* Result
    )
{
    RETURN_STATUS Status;

    if (Operand <= MAX_INT32)
    {
        *Result = (INT32)Operand;
        Status = RETURN_SUCCESS;
    }
    else
    {
        *Result = INT32_ERROR;
        Status = RETURN_BUFFER_TOO_SMALL;
    }

    return Status;
}

//
// UINT32 -> INTN conversion
//
RETURN_STATUS
EFIAPI
SafeUInt32ToIntN(
    IN UINT32 Operand,
    OUT INTN* Result
    )
{
    *Result = Operand;
    return RETURN_SUCCESS;
}

//
// INTN -> INT8 conversion
//
RETURN_STATUS
EFIAPI
SafeIntNToInt8(
    IN INTN Operand,
    OUT INT8* Result
    )
{
    RETURN_STATUS Status;
    
    if ((Operand >= MIN_INT8) && (Operand <= MAX_INT8))
    {
        *Result = (INT8)Operand;
        Status = RETURN_SUCCESS;
    }
    else
    {
        *Result = INT8_ERROR;
        Status = RETURN_BUFFER_TOO_SMALL;
    }
    
    return Status;
}

//
// INTN -> CHAR8 conversion
//
RETURN_STATUS
EFIAPI
SafeIntNToChar8(
    IN INTN Operand,
    OUT CHAR8* Result
    )
{
    return SafeIntNToInt8(Operand, (INT8*)Result);
}

//
// INTN -> UINT8 conversion
//
RETURN_STATUS
EFIAPI
SafeIntNToUInt8(
    IN INTN Operand,
    OUT UINT8* pui8Result
    )
{
    RETURN_STATUS Status;
    
    if ((Operand >= 0) && (Operand <= MAX_UINT8))
    {
        *pui8Result = (UINT8)Operand;
        Status = RETURN_SUCCESS;
    }
    else
    {
        *pui8Result = UINT8_ERROR;
        Status = RETURN_BUFFER_TOO_SMALL;
    }
    
    return Status;
}

//
// INTN -> INT16 conversion
//
RETURN_STATUS
EFIAPI
SafeIntNToInt16(
    IN INTN Operand,
    OUT INT16* Result
    )
{
    RETURN_STATUS Status;
    
    if ((Operand >= MIN_INT16) && (Operand <= MAX_INT16))
    {
        *Result = (INT16)Operand;
        Status = RETURN_SUCCESS;
    }
    else
    {
        *Result = INT16_ERROR;
        Status = RETURN_BUFFER_TOO_SMALL;
    }
    
    return Status;
}    

//
// INTN -> UINT16 conversion
//
RETURN_STATUS
EFIAPI
SafeIntNToUInt16(
    IN INTN Operand,
    OUT UINT16* Result
    )
{
    RETURN_STATUS Status;
    
    if ((Operand >= 0) && (Operand <= MAX_UINT16))
    {
        *Result = (UINT16)Operand;
        Status = RETURN_SUCCESS;
    }
    else
    {
        *Result = UINT16_ERROR;
        Status = RETURN_BUFFER_TOO_SMALL;
    }
    
    return Status;
}

//
// INTN -> INT32 conversion
//
RETURN_STATUS
EFIAPI
SafeIntNToInt32(
    IN INTN Operand,
    OUT INT32* Result
    )
{
    return SafeInt64ToInt32((INT64) Operand, Result);
}

//
// INTN -> UINT32 conversion
//
RETURN_STATUS
EFIAPI
SafeIntNToUInt32(
    IN INTN Operand,
    OUT UINT32* Result
    )
{
    return SafeInt64ToUInt32((INT64)Operand, Result);
}

//
// INTN -> UINTN conversion
//
RETURN_STATUS
EFIAPI
SafeIntNToUIntN(
    IN INTN Operand,
    OUT UINTN* Result
    )
{
    RETURN_STATUS Status;
    
    if (Operand >= 0)
    {
        *Result = (UINTN)Operand;
        Status = RETURN_SUCCESS;
    }
    else
    {
        *Result = UINTN_ERROR;
        Status = RETURN_BUFFER_TOO_SMALL;
    }
    
    return Status;
}

//
// INTN -> UINT64 conversion
//
RETURN_STATUS
EFIAPI
SafeIntNToUInt64(
    IN INTN Operand,
    OUT UINT64* Result
    )
{
    RETURN_STATUS Status;
    
    if (Operand >= 0)
    {
        *Result = (UINT64)Operand;
        Status = RETURN_SUCCESS;
    }
    else
    {
        *Result = UINT64_ERROR;
        Status = RETURN_BUFFER_TOO_SMALL;
    }
    
    return Status;
}

//
// UINTN -> INT8 conversion
//
RETURN_STATUS
EFIAPI
SafeUIntNToInt8(
    IN UINTN Operand,
    OUT INT8* Result
    )
{
    RETURN_STATUS Status;
    
    if (Operand <= MAX_INT8)
    {
        *Result = (INT8)Operand;
        Status = RETURN_SUCCESS;
    }
    else
    {
        *Result = INT8_ERROR;
        Status = RETURN_BUFFER_TOO_SMALL;
    }
    
    return Status;
}

//
// UINTN -> CHAR8 conversion
//
RETURN_STATUS
EFIAPI
SafeUIntNToChar8(
    IN UINTN Operand,
    OUT CHAR8* Result
    )
{
    return SafeUIntNToInt8(Operand, (INT8*)Result);
}

//
// UINTN -> UINT8 conversion
//
RETURN_STATUS
EFIAPI
SafeUIntNToUInt8(
    IN UINTN Operand,
    OUT UINT8* pui8Result
    )
{
    RETURN_STATUS Status;
    
    if (Operand <= MAX_UINT8)
    {
        *pui8Result = (UINT8)Operand;
        Status = RETURN_SUCCESS;
    }
    else
    {
        *pui8Result = UINT8_ERROR;
        Status = RETURN_BUFFER_TOO_SMALL;
    }
    
    return Status;
}

//
// UINTN -> INT16 conversion
//
RETURN_STATUS
EFIAPI
SafeUIntNToInt16(
    IN UINTN Operand,
    OUT INT16* Result
    )
{
    RETURN_STATUS Status;

    if (Operand <= MAX_INT16)
    {
        *Result = (INT16)Operand;
        Status = RETURN_SUCCESS;
    }
    else
    {
        *Result = INT16_ERROR;
        Status = RETURN_BUFFER_TOO_SMALL;
    }

    return Status; 
}

//
// UINTN -> UINT16 conversion
//
RETURN_STATUS
EFIAPI
SafeUIntNToUInt16(
    IN UINTN Operand,
    OUT UINT16* Result
    )
{
    RETURN_STATUS Status;

    if (Operand <= MAX_UINT16)
    {
        *Result = (UINT16)Operand;
        Status = RETURN_SUCCESS;
    }
    else
    {
        *Result = UINT16_ERROR;
        Status = RETURN_BUFFER_TOO_SMALL;
    }

    return Status;
}

//
// UINTN -> INT32 conversion
//
RETURN_STATUS
EFIAPI
SafeUIntNToInt32(
    IN UINTN Operand,
    OUT INT32* Result
    )
{
    RETURN_STATUS Status;
    
    if (Operand <= MAX_INT32)
    {
        *Result = (INT32)Operand;
        Status = RETURN_SUCCESS;
    }
    else
    {
        *Result = INT32_ERROR;
        Status = RETURN_BUFFER_TOO_SMALL;
    }
    
    return Status;
}

//
// UINTN -> UINT32 conversion
//
RETURN_STATUS
EFIAPI
SafeUIntNToUInt32(
    IN UINTN Operand,
    OUT UINT32* Result
    )
{
    return SafeUInt64ToUInt32((UINT64)Operand, Result);
}

//        
// UINTN -> INTN conversion
//
RETURN_STATUS
EFIAPI
SafeUIntNToIntN(
    IN UINTN Operand,
    OUT INTN* Result
    )
{
    RETURN_STATUS Status;
    
    if (Operand <= MAX_INTN)
    {
        *Result = (INTN)Operand;
        Status = RETURN_SUCCESS;
    }
    else
    {
        *Result = INTN_ERROR;
        Status = RETURN_BUFFER_TOO_SMALL;
    }
    
    return Status;
}

//
// UINTN -> INT64 conversion
//
RETURN_STATUS
EFIAPI
SafeUIntNToInt64(
    IN UINTN Operand,
    OUT INT64* Result
    )
{
    return SafeUInt64ToInt64((UINT64)Operand, Result);
}

//
// INT64 -> INT8 conversion
//
RETURN_STATUS
EFIAPI
SafeInt64ToInt8(
    IN INT64 Operand,
    OUT INT8* Result
    )
{
    RETURN_STATUS Status;
    
    if ((Operand >= MIN_INT8) && (Operand <= MAX_INT8))
    {
        *Result = (INT8)Operand;
        Status = RETURN_SUCCESS;
    }
    else
    {
        *Result = INT8_ERROR;
        Status = RETURN_BUFFER_TOO_SMALL;
    }

    return Status;
}

//
// INT64 -> CHAR8 conversion
//
RETURN_STATUS
EFIAPI
SafeInt64ToChar8(
    IN INT64 Operand,
    OUT CHAR8* Result
    )
{
    return SafeInt64ToInt8(Operand, (INT8*)Result);
}

//
// INT64 -> UINT8 conversion
//
RETURN_STATUS
EFIAPI
SafeInt64ToUInt8(
    IN INT64 Operand,
    OUT UINT8* Result
    )
{
    RETURN_STATUS Status;
    
    if ((Operand >= 0) && (Operand <= MAX_UINT8))
    {
        *Result = (UINT8)Operand;
        Status = RETURN_SUCCESS;
    }
    else
    {
        *Result = UINT8_ERROR;
        Status = RETURN_BUFFER_TOO_SMALL;
    }
    
    return Status;
}

//
// INT64 -> INT16 conversion
//
RETURN_STATUS
EFIAPI
SafeInt64ToInt16(
    IN INT64 Operand,
    OUT INT16* Result
    )
{
    RETURN_STATUS Status;
    
    if ((Operand >= MIN_INT16) && (Operand <= MAX_INT16))
    {
        *Result = (INT16)Operand;
        Status = RETURN_SUCCESS;
    }
    else
    {
        *Result = INT16_ERROR;
        Status = RETURN_BUFFER_TOO_SMALL;
    }
    
    return Status;
}

//
// INT64 -> UINT16 conversion
//
RETURN_STATUS
EFIAPI
SafeInt64ToUInt16(
    IN INT64 Operand,
    OUT UINT16* Result
    )
{
    RETURN_STATUS Status;
    
    if ((Operand >= 0) && (Operand <= MAX_UINT16))
    {
        *Result = (UINT16)Operand;
        Status = RETURN_SUCCESS;
    }
    else
    {
        *Result = UINT16_ERROR;
        Status = RETURN_BUFFER_TOO_SMALL;
    }
    
    return Status;
}

//
// INT64 -> INT32 conversion
//
RETURN_STATUS
EFIAPI
SafeInt64ToInt32(
    IN INT64 Operand,
    OUT INT32* Result
    )
{
    RETURN_STATUS Status;
    
    if ((Operand >= MIN_INT32) && (Operand <= MAX_INT32))
    {
        *Result = (INT32)Operand;
        Status = RETURN_SUCCESS;
    }
    else
    {
        *Result = INT32_ERROR;
        Status = RETURN_BUFFER_TOO_SMALL;
    }
    
    return Status;
}

//
// INT64 -> UINT32 conversion
//
RETURN_STATUS
EFIAPI
SafeInt64ToUInt32(
    IN INT64 Operand,
    OUT UINT32* Result
    )
{
    RETURN_STATUS Status;
    
    if ((Operand >= 0) && (Operand <= MAX_UINT32))
    {
        *Result = (UINT32)Operand;
        Status = RETURN_SUCCESS;
    }
    else
    {
        *Result = UINT32_ERROR;
        Status = RETURN_BUFFER_TOO_SMALL;
    }
    
    return Status;    
}

//
// INT64 -> INTN conversion
//
RETURN_STATUS
EFIAPI
SafeInt64ToIntN(
    IN INT64 Operand,
    OUT INTN* Result
    )
{
    *Result = (INTN)Operand;
    return RETURN_SUCCESS;
}

//
// INT64 -> UINTN conversion
//
RETURN_STATUS
EFIAPI
SafeInt64ToUIntN(
    IN INT64 Operand,
    OUT UINTN* Result
    )
{
    return SafeInt64ToUInt64(Operand, (UINT64*)Result); 
}

//
// INT64 -> UINT64 conversion
//
RETURN_STATUS
EFIAPI
SafeInt64ToUInt64(
    IN INT64 Operand,
    OUT UINT64* Result
    )
{
    RETURN_STATUS Status;
    
    if (Operand >= 0)
    {
        *Result = (UINT64)Operand;
        Status = RETURN_SUCCESS;
    }
    else
    {
        *Result = UINT64_ERROR;
        Status = RETURN_BUFFER_TOO_SMALL;
    }
    
    return Status; 
}

//
// UINT64 -> INT8 conversion
//
RETURN_STATUS
EFIAPI
SafeUInt64ToInt8(
    IN UINT64 Operand,
    OUT INT8* Result
    )
{
    RETURN_STATUS Status;
    
    if (Operand <= MAX_INT8)
    {
        *Result = (INT8)Operand;
        Status = RETURN_SUCCESS;
    }
    else
    {
        *Result = INT8_ERROR;
        Status = RETURN_BUFFER_TOO_SMALL;
    }
    
    return Status;
}

//
// UINT64 -> CHAR8 conversion
//
RETURN_STATUS
EFIAPI
SafeUInt64ToChar8(
    IN UINT64 Operand,
    OUT CHAR8* Result
    )
{
    return SafeUInt64ToInt8(Operand, (INT8*)Result);
}

//
// UINT64 -> UINT8 conversion
//
RETURN_STATUS
EFIAPI
SafeUInt64ToUInt8(
    IN UINT64 Operand,
    OUT UINT8* Result
    )
{
    RETURN_STATUS Status;
    
    if (Operand <= MAX_UINT8)
    {
        *Result = (UINT8)Operand;
        Status = RETURN_SUCCESS;
    }
    else
    {
        *Result = UINT8_ERROR;
        Status = RETURN_BUFFER_TOO_SMALL;
    }
    
    return Status;
}

//
// UINT64 -> INT16 conversion
//
RETURN_STATUS
EFIAPI
SafeUInt64ToInt16(
    IN UINT64 Operand,
    OUT INT16* Result
    )
{
    RETURN_STATUS Status;
    
    if (Operand <= MAX_INT16)
    {
        *Result = (INT16)Operand;
        Status = RETURN_SUCCESS;
    }
    else
    {
        *Result = INT16_ERROR;
        Status = RETURN_BUFFER_TOO_SMALL;
    }
    
    return Status;
}

//
// UINT64 -> UINT16 conversion
//
RETURN_STATUS
EFIAPI
SafeUInt64ToUInt16(
    IN UINT64 Operand,
    OUT UINT16* Result
    )
{
    RETURN_STATUS Status;
    
    if (Operand <= MAX_UINT16)
    {
        *Result = (UINT16)Operand;
        Status = RETURN_SUCCESS;
    }
    else
    {
        *Result = UINT16_ERROR;
        Status = RETURN_BUFFER_TOO_SMALL;
    }
    
    return Status;
}

//
// UINT64 -> INT32 conversion
//
RETURN_STATUS
EFIAPI
SafeUInt64ToInt32(
    IN UINT64 Operand,
    OUT INT32* Result
    )
{
    RETURN_STATUS Status;
    
    if (Operand <= MAX_INT32)
    {
        *Result = (INT32)Operand;
        Status = RETURN_SUCCESS;
    }
    else
    {
        *Result = INT32_ERROR;
        Status = RETURN_BUFFER_TOO_SMALL;
    }
    
    return Status;
}

//
// UINT64 -> UINT32 conversion
//
RETURN_STATUS
EFIAPI
SafeUInt64ToUInt32(
    IN UINT64 Operand,
    OUT UINT32* Result
    )
{
    RETURN_STATUS Status;
    
    if (Operand <= MAX_UINT32)
    {
        *Result = (UINT32)Operand;
        Status = RETURN_SUCCESS;
    }
    else
    {
        *Result = UINT32_ERROR;
        Status = RETURN_BUFFER_TOO_SMALL;
    }
    
    return Status;
}

//
// UINT64 -> INTN conversion
//
RETURN_STATUS
EFIAPI
SafeUInt64ToIntN(
    IN UINT64 Operand,
    OUT INTN* Result
    )
{
    RETURN_STATUS Status;
    
    if (Operand <= MAX_INTN)
    {
        *Result = (INTN)Operand;
        Status = RETURN_SUCCESS;
    }
    else
    {
        *Result = INTN_ERROR;
        Status = RETURN_BUFFER_TOO_SMALL;
    }
    
    return Status;
}

//
// UINT64 -> UINTN conversion
//
RETURN_STATUS
EFIAPI
SafeUInt64ToUIntN(
    IN UINT64 Operand,
    OUT UINTN* Result
    )
{
    *Result = Operand;
    return RETURN_SUCCESS;
}

//
// UINT64 -> INT64 conversion
//
RETURN_STATUS
EFIAPI
SafeUInt64ToInt64(
    IN UINT64 Operand,
    OUT INT64* Result
    )
{
    RETURN_STATUS Status;
    
    if (Operand <= MAX_INT64)
    {
        *Result = (INT64)Operand;
        Status = RETURN_SUCCESS;
    }
    else
    {
        *Result = INT64_ERROR;
        Status = RETURN_BUFFER_TOO_SMALL;
    }
    
    return Status;
}

//=============================================================================
// Addition functions
//=============================================================================

//
// UINT8 addition
//
RETURN_STATUS
EFIAPI
SafeUInt8Add(
    IN UINT8 Augend,
    IN UINT8 Addend,
    OUT UINT8* Result
    )
{
    RETURN_STATUS Status;

    if (((UINT8)(Augend + Addend)) >= Augend)
    {
        *Result = (UINT8)(Augend + Addend);
        Status = RETURN_SUCCESS;
    }
    else
    {
        *Result = UINT8_ERROR;
        Status = RETURN_BUFFER_TOO_SMALL;
    }
    
    return Status;
}

//
// UINT16 addition
//
RETURN_STATUS
EFIAPI
SafeUInt16Add(
    IN UINT16 Augend,
    IN UINT16 Addend,
    OUT UINT16* Result
    )
{
    RETURN_STATUS Status;

    if (((UINT16)(Augend + Addend)) >= Augend)
    {
        *Result = (UINT16)(Augend + Addend);
        Status = RETURN_SUCCESS;
    }
    else
    {
        *Result = UINT16_ERROR;
        Status = RETURN_BUFFER_TOO_SMALL;
    }
    
    return Status;
}

//
// UINT32 addition
//
RETURN_STATUS
EFIAPI
SafeUInt32Add(
    IN UINT32 Augend,
    IN UINT32 Addend,
    OUT UINT32* Result
    )
{
    RETURN_STATUS Status;

    if ((Augend + Addend) >= Augend)
    {
        *Result = (Augend + Addend);
        Status = RETURN_SUCCESS;
    }
    else
    {
        *Result = UINT32_ERROR;
        Status = RETURN_BUFFER_TOO_SMALL;
    }
    
    return Status;
}

//
// UINTN addition
//
RETURN_STATUS
EFIAPI
SafeUIntNAdd(
    IN UINTN Augend,
    IN UINTN Addend,
    OUT UINTN* Result
    )
{
    return SafeUInt64Add((UINT64)Augend, (UINT64)Addend, (UINT64*)Result);
}

//
// UINT64 addition
//
RETURN_STATUS
EFIAPI
SafeUInt64Add(
    IN UINT64 Augend,
    IN UINT64 Addend,
    OUT UINT64* Result
    )
{
    RETURN_STATUS Status;

    if ((Augend + Addend) >= Augend)
    {
        *Result = (Augend + Addend);
        Status = RETURN_SUCCESS;
    }
    else
    {
        *Result = UINT64_ERROR;
        Status = RETURN_BUFFER_TOO_SMALL;
    }
    
    return Status;
}

//=============================================================================
// Subtraction functions
//=============================================================================

//
// UINT8 subtraction
//
RETURN_STATUS
EFIAPI
SafeUInt8Sub(
    IN UINT8 Minuend,
    IN UINT8 Subtrahend,
    OUT UINT8* Result
    )
{
    RETURN_STATUS Status;
    
    if (Minuend >= Subtrahend)
    {
        *Result = (UINT8)(Minuend - Subtrahend);
        Status = RETURN_SUCCESS;
    }
    else
    {
        *Result = UINT8_ERROR;
        Status = RETURN_BUFFER_TOO_SMALL;
    }
    
    return Status;
}

//
// UINT16 subtraction
//
RETURN_STATUS
EFIAPI
SafeUInt16Sub(
    IN UINT16 Minuend,
    IN UINT16 Subtrahend,
    OUT UINT16* Result
    )
{
    RETURN_STATUS Status;

    if (Minuend >= Subtrahend)
    {
        *Result = (UINT16)(Minuend - Subtrahend);
        Status = RETURN_SUCCESS;
    }
    else
    {
        *Result = UINT16_ERROR;
        Status = RETURN_BUFFER_TOO_SMALL;
    }
    
    return Status;
}

//
// UINT32 subtraction
//
RETURN_STATUS
EFIAPI
SafeUInt32Sub(
    IN UINT32 Minuend,
    IN UINT32 Subtrahend,
    OUT UINT32* Result
    )
{
    RETURN_STATUS Status;

    if (Minuend >= Subtrahend)
    {
        *Result = (Minuend - Subtrahend);
        Status = RETURN_SUCCESS;
    }
    else
    {
        *Result = UINT32_ERROR;
        Status = RETURN_BUFFER_TOO_SMALL;
    }
    
    return Status;
}

//
// UINTN subtraction
//
RETURN_STATUS
EFIAPI
SafeUIntNSub(
    IN UINTN Minuend,
    IN UINTN Subtrahend,
    OUT UINTN* Result
    )
{
    return SafeUInt64Sub((UINT64)Minuend, (UINT64)Subtrahend, (UINT64*)Result);
}

//
// UINT64 subtraction
//
RETURN_STATUS
EFIAPI
SafeUInt64Sub(
    IN UINT64 Minuend,
    IN UINT64 Subtrahend,
    OUT UINT64* Result
    )
{
    RETURN_STATUS Status;

    if (Minuend >= Subtrahend)
    {
        *Result = (Minuend - Subtrahend);
        Status = RETURN_SUCCESS;
    }
    else
    {
        *Result = UINT64_ERROR;
        Status = RETURN_BUFFER_TOO_SMALL;
    }
    
    return Status;
}

//=============================================================================
// Multiplication functions
//=============================================================================

//
// UINT8 multiplication
//
RETURN_STATUS
EFIAPI
SafeUInt8Mult(
    IN UINT8 Multiplicand,
    IN UINT8 Multiplier,
    OUT UINT8* Result
    )
{
    UINT32 intermediateResult = ((UINT32)Multiplicand) * ((UINT32)Multiplier);
    
    return SafeUInt32ToUInt8(intermediateResult, Result);
}    

//
// UINT16 multiplication
//
RETURN_STATUS
EFIAPI
SafeUInt16Mult(
    IN UINT16 Multiplicand,
    IN UINT16 Multiplier,
    OUT UINT16* Result
    )
{
    UINT32 intermediateResult = ((UINT32)Multiplicand) * ((UINT32)Multiplier);
    
    return SafeUInt32ToUInt16(intermediateResult, Result);
}

//
// UINT32 multiplication
//
RETURN_STATUS
EFIAPI
SafeUInt32Mult(
    IN UINT32 Multiplicand,
    IN UINT32 Multiplier,
    OUT UINT32* Result
    )
{
    UINT64 intermediateResult = SafeUInt32x32To64(Multiplicand, Multiplier);

    return SafeUInt64ToUInt32(intermediateResult, Result);
}

//
// UINTN multiplication
//
RETURN_STATUS
EFIAPI
SafeUIntNMult(
    IN UINTN Multiplicand,
    IN UINTN Multiplier,
    OUT UINTN* Result
    )
{
    return SafeUInt64Mult((UINT64)Multiplicand, (UINT64)Multiplier, (UINT64*)Result);
}

//
// UINT64 multiplication
//
RETURN_STATUS
EFIAPI
SafeUInt64Mult(
    IN UINT64 Multiplicand,
    IN UINT64 Multiplier,
    OUT UINT64* Result
    )
{
    RETURN_STATUS Status;
    // 64x64 into 128 is like 32.32 x 32.32.
    //
    // a.b * c.d = a*(c.d) + .b*(c.d) = a*c + a*.d + .b*c + .b*.d
    // back in non-decimal notation where A=a*2^32 and C=c*2^32:  
    // A*C + A*d + b*C + b*d
    // So there are four components to add together.
    //   result = (a*c*2^64) + (a*d*2^32) + (b*c*2^32) + (b*d)
    //
    // a * c must be 0 or there would be bits in the high 64-bits
    // a * d must be less than 2^32 or there would be bits in the high 64-bits
    // b * c must be less than 2^32 or there would be bits in the high 64-bits
    // then there must be no overflow of the resulting values summed up.
    
    UINT32 dw_a;
    UINT32 dw_b;
    UINT32 dw_c;
    UINT32 dw_d;
    UINT64 ad = 0;
    UINT64 bc = 0;
    UINT64 bd = 0;
    UINT64 unsignedResult = 0;

    Status = RETURN_BUFFER_TOO_SMALL;
    
    dw_a = (UINT32)(Multiplicand >> 32);
    dw_c = (UINT32)(Multiplier >> 32);

    // common case -- if high dwords are both zero, no chance for overflow
    if ((dw_a == 0) && (dw_c == 0))
    {
        dw_b = (UINT32)Multiplicand;
        dw_d = (UINT32)Multiplier;

        *Result = (((UINT64)dw_b) * (UINT64)dw_d);
        Status = RETURN_SUCCESS;
    }
    else
    {
        // a * c must be 0 or there would be bits set in the high 64-bits
        if ((dw_a == 0) ||
            (dw_c == 0))
        {
            dw_d = (UINT32)Multiplier;

            // a * d must be less than 2^32 or there would be bits set in the high 64-bits
            ad = (((UINT64)dw_a) * (UINT64)dw_d);
            if ((ad & 0xffffffff00000000) == 0)
            {
                dw_b = (UINT32)Multiplicand;

                // b * c must be less than 2^32 or there would be bits set in the high 64-bits
                bc = (((UINT64)dw_b) * (UINT64)dw_c);
                if ((bc & 0xffffffff00000000) == 0)
                {
                    // now sum them all up checking for overflow.
                    // shifting is safe because we already checked for overflow above
                    if (!RETURN_ERROR(SafeUInt64Add(bc << 32, ad << 32, &unsignedResult)))                        
                    {
                        // b * d
                        bd = (((UINT64)dw_b) * (UINT64)dw_d);
                    
                        if (!RETURN_ERROR(SafeUInt64Add(unsignedResult, bd, &unsignedResult)))
                        {
                            *Result = unsignedResult;
                            Status = RETURN_SUCCESS;
                        }
                    }
                }
            }
        }
    }

    if (RETURN_ERROR(Status))
    {
        *Result = UINT64_ERROR;
    }
    return Status;
}

/////////////////////////////////////////////////////////////////////////
//
// signed operations
//
// Strongly consider using unsigned numbers.
//
// Signed numbers are often used where unsigned numbers should be used.
// For example file sizes and array indices should always be unsigned.
// Subtracting a larger positive signed number from a smaller positive
// signed number with SafeInt32Sub will succeed, producing a negative number,
// that then must not be used as an array index (but can occasionally be
// used as a pointer index.) Similarly for adding a larger magnitude
// negative number to a smaller magnitude positive number.
//
// intsafe.h does not protect you from such errors. It tells you if your
// integer operations overflowed, not if you are doing the right thing
// with your non-overflowed integers.
//
// Likewise you can overflow a buffer with a non-overflowed unsigned index.
//

//=============================================================================
// Signed addition functions
//=============================================================================

//
// INT8 Addition
//
RETURN_STATUS
EFIAPI
SafeInt8Add(
    IN INT8 Augend,
    IN INT8 Addend,
    OUT INT8* Result
    )
{
    return SafeInt32ToInt8(((INT32)Augend) + ((INT32)Addend), Result);
}

//
// INT16 Addition
//
RETURN_STATUS
EFIAPI
SafeInt16Add(
    IN INT16 Augend,
    IN INT16 Addend,
    OUT INT16* Result
    )
{
    return SafeInt32ToInt16(((INT32)Augend) + ((INT32)Addend), Result);
}

//
// INT32 Addition
//
RETURN_STATUS
EFIAPI
SafeInt32Add(
    IN INT32 Augend,
    IN INT32 Addend,
    OUT INT32* Result
    )
{
    return SafeInt64ToInt32(((INT64)Augend) + ((INT64)Addend), Result);
}

//
// INTN Addition
//
RETURN_STATUS
EFIAPI
SafeIntNAdd(
    IN INTN Augend,
    IN INTN Addend,
    OUT INTN* Result
    )
{
    return SafeInt64Add((INT64)Augend, (INT64)Addend, (INT64*)Result);
}

//
// INT64 Addition
//
RETURN_STATUS
EFIAPI
SafeInt64Add(
    IN INT64 Augend,
    IN INT64 Addend,
    OUT INT64* Result
    )
{
    RETURN_STATUS Status;
    INT64 signedResult = Augend + Addend;
    
    //
    // Adding positive to negative never overflows.
    // If you add two positive numbers, you expect a positive result.
    // If you add two negative numbers, you expect a negative result.
    // Overflow if inputs are the same sign and output is not that sign.
    //
    if (((Augend < 0) == (Addend < 0))  &&
        ((Augend < 0) != (signedResult < 0)))
    {
        *Result = INT64_ERROR;
        Status = RETURN_BUFFER_TOO_SMALL;
    }
    else
    {
        *Result = signedResult;
        Status = RETURN_SUCCESS;
    }

    return Status;
}

//=============================================================================
// Signed subtraction functions
//=============================================================================

//
// INT8 Subtraction
//
RETURN_STATUS
EFIAPI
SafeInt8Sub(
    IN INT8 Minuend,
    IN INT8 Subtrahend,
    OUT INT8* Result
    )
{
    return SafeInt32ToInt8(((INT32)Minuend) - ((INT32)Subtrahend), Result);
}

//
// INT16 Subtraction
//
RETURN_STATUS
EFIAPI
SafeInt16Sub(
    IN INT16 Minuend,
    IN INT16 Subtrahend,
    OUT INT16* Result
    )
{
    return SafeInt32ToInt16(((INT32)Minuend) - ((INT32)Subtrahend), Result);
}

//
// INT32 Subtraction
//
RETURN_STATUS
EFIAPI
SafeInt32Sub(
    IN INT32 Minuend,
    IN INT32 Subtrahend,
    OUT INT32* Result
    )
{
    return SafeInt64ToInt32(((INT64)Minuend) - ((INT64)Subtrahend), Result);
}

//
// INTN Subtraction
//
RETURN_STATUS
EFIAPI
SafeIntNSub(
    IN INTN Minuend,
    IN INTN Subtrahend,
    OUT INTN* Result
    )
{
    return SafeInt64Sub((INT64)Minuend, (INT64)Subtrahend, (INT64*)Result);
}

//
// INT64 Subtraction
//
RETURN_STATUS
EFIAPI
SafeInt64Sub(
    IN INT64 Minuend,
    IN INT64 Subtrahend,
    OUT INT64* Result
    )
{
    RETURN_STATUS Status;
    INT64 signedResult = Minuend - Subtrahend;

    //
    // Subtracting a positive number from a positive number never overflows.
    // Subtracting a negative number from a negative number never overflows.
    // If you subtract a negative number from a positive number, you expect a positive result.
    // If you subtract a positive number from a negative number, you expect a negative result.
    // Overflow if inputs vary in sign and the output does not have the same sign as the first input.
    //
    if (((Minuend < 0) != (Subtrahend < 0)) &&
        ((Minuend < 0) != (signedResult < 0)))
    {
        *Result = INT64_ERROR;
        Status = RETURN_BUFFER_TOO_SMALL;
    }
    else
    {
        *Result = signedResult;
        Status = RETURN_SUCCESS;
    }
    
    return Status;
}

//=============================================================================
// Signed multiplication functions
//=============================================================================

//
// INT8 multiplication
//
RETURN_STATUS
EFIAPI
SafeInt8Mult(
    IN INT8 Multiplicand,
    IN INT8 Multiplier,
    OUT INT8* Result
    )
{
    return SafeInt32ToInt8(((INT32)Multiplier) * ((INT32)Multiplicand), Result);
}

//
// INT16 multiplication
//
RETURN_STATUS
EFIAPI
SafeInt16Mult(
    IN INT16 Multiplicand,
    IN INT16 Multiplier,
    OUT INT16* Result
    )
{
    return SafeInt32ToInt16(((INT32)Multiplicand) * ((INT32)Multiplier), Result);
}

//
// INT32 multiplication
//
RETURN_STATUS
EFIAPI
SafeInt32Mult(
    IN INT32 Multiplicand,
    IN INT32 Multiplier,
    OUT INT32* Result
    )
{
    return SafeInt64ToInt32(((INT64)Multiplicand) * ((INT64)Multiplier), Result);
}

//
// INTN multiplication
//
RETURN_STATUS
EFIAPI
SafeIntNMult(
    IN INTN Multiplicand,
    IN INTN Multiplier,
    OUT INTN* Result
    )
{
    return SafeInt64Mult((INT64)Multiplicand, (INT64)Multiplier, (INT64*)Result);
}

//
// INT64 multiplication
//
RETURN_STATUS
EFIAPI
SafeInt64Mult(
    IN INT64 Multiplicand,
    IN INT64 Multiplier,
    OUT INT64* Result
    )
{
    RETURN_STATUS Status;

    //
    // Split into sign and magnitude, do unsigned operation, apply sign.
    //
    
    UINT64 unsignedMultiplicand;
    UINT64 unsignedMultiplier;
    UINT64 unsignedResult;
    CONST UINT64 MIN_INT64_MAGNITUDE = ((((UINT64) - (MIN_INT64 + 1))) + 1);

    if (Multiplicand < 0)
    {
        //
        // Avoid negating the most negative number.
        //
        unsignedMultiplicand = ((UINT64)(- (Multiplicand + 1))) + 1;
    }
    else
    {
        unsignedMultiplicand = (UINT64)Multiplicand;
    }

    if (Multiplier < 0)
    {
        //
        // Avoid negating the most negative number.
        //
        unsignedMultiplier = ((UINT64)(- (Multiplier + 1))) + 1;
    }
    else
    {
        unsignedMultiplier = (UINT64)Multiplier;
    }

    Status = SafeUInt64Mult(unsignedMultiplicand, unsignedMultiplier, &unsignedResult);
    if (!RETURN_ERROR(Status))
    {
        if ((Multiplicand < 0) != (Multiplier < 0))
        {
            if (unsignedResult > MIN_INT64_MAGNITUDE)
            {
                *Result = INT64_ERROR;
                Status = RETURN_BUFFER_TOO_SMALL;
            }
            else
            {
                *Result = - ((INT64)unsignedResult);
            }
        }
        else
        {
            if (unsignedResult > MAX_INT64)
            {
                *Result = INT64_ERROR;
                Status = RETURN_BUFFER_TOO_SMALL;
            }
            else
            {
                *Result = (INT64)unsignedResult;
            }
        }
    }
    else
    {
        *Result = INT64_ERROR;
    }
    return Status;
}

